P_DisStates_Question2 <- c(0.0990991, 0.09009009, 0.8108108)
P_DisStates_Question4 <- c(0.0516333, 0.711275, 0.2370917)
probability_table <- data.frame(Disease_State = c("Normal", "Lung Cancer", "Sarcoidosis"),
Q2_Inherent_Probability = P_Question2, Q4_Inherent_Probability = P_Question4,
Q2_Conditional_Probability = P_DisStates_Question2, Q4_Conditional_Probability = P_DisStates_Question4)
print(probability_table)
#'CODE ANALYSUIS:In this code I do the exact same calculation as in question 2 but
#'with the new values provided. I also makee a table comparing the values from
#'question 2 and queestion 4 so they can be more easily compared.
##################################################################################
#'Q5 (6 points):
#'Similar with other distributions, R has 4 functions for the
#'t-distribution. They have one parameter for the degrees of freedom (ignore the
#' “non-centrality parameter”). Use the function dt in a way similar to what we
#' covered in the tutorial, in order to reproduce the plot found in the slides,
#' with the densities of the standard normal and some t-distributions with
#' different degrees of freedom. You cannot use the plot function many times for
#' each density plot, as a new call of the plot function removes the previous plot.
#' Instead, after the first call of the plot function, you will need to use the
#' “points” function, witch has a very similar syntax with the plot function.
#' Every time you use the “points” function, a new plot is added to the existing
#' plot.Use the argument “col” in order to use different colors for the different
#' plots. Explore the “legend” function in order to create an informative legend
#' for the plot.
degrees_of_freedom <- c(8, 4, 2, 1)
#CODE ANALYSIS: With this line of code I aim to create a vector that contains the degrees of
#freedom that I am interested in for the t-distribution
x <- seq(-4, 8.5, length.out = 100)
#' CODE ANALYSIS: In this line of code I establish the range that I want to b plotted for my x-
#' value, I picked a range of -4 to 8.5 because this is the range that was used
#' in the example found in the class slides. I use the length.out function to
#' indicate the amount of values I want for there to be plotted for the sequence,
#' selecting a large number like 100 gives me a smooth plot.
plot(x, dnorm(x), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 1),
xlim = c(-4, 8), ylim = c(0, 0.7),
xlab = "", ylab = "", main = "t-distribtution examples", yaxt = "n", bty = "n")
tick_labels <- c("", "", "", "", "", "")
tick_positions <- c("-3", "-1", "1", "3", "5", "7")
axis(1, at = tick_positions, labels = tick_labels, tck = -0.005)
#' CODE ANALYSIS: For this code I plot the normal distribution using the plot() function to plot
#' the normal distribution. I use the dnorm() function to calculate the probability
#' density function for a standard normal distribution given the x values provided
#' previously. I then specify the type of plot as type = 1 which corresponds to a
#' line plot, the col parameter is specified using the rgb() function is used to
#' specify the exact colour I want for my plot line, the values added in this
#' function correspond to specific colour codes for red, blue, and green, allowing
#' me to generate the preferred shade of blue. The alpha = parameter lets me specify
#' the transparency of the colour which I left at 1 indicating 0% transparency.I
#' then indicated what I want my x axis and y axis length to be in thee xlim and
#' ylim parameters. I did not enter anything but quotations in the xlab and ylab
#' parameters because I do not want any axis labels as there wasn't any in the
#' class example. I made the title the same as the class example by adding the
#' name to the "main="parameter. I then add thee "yaxt=n" and "bty=n" parameters
#' which get rid of the y axis and box around the plot respectively. I also create
#' a vector called tick labels and tick positions and use these vectors to fill in
#' the parameters for thee axis() function. The tick_labels vector specifies that
#' at every tick there should not be any labels while the tick_position vector
#' has the points at which I would like my ticks to be placed on the plot. The tck
#' parameter specifies which direction I want the ticks to face and how long I want
#' them to be
points(x, dt(x, degrees_of_freedom[1]), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 0.8))
points(x, dt(x, degrees_of_freedom[2]), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 0.6))
points(x, dt(x, degrees_of_freedom[3]), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 0.4))
points(x, dt(x, degrees_of_freedom[4]), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 0.2))
#CODE ANALYSIS: Here I use the points function to plot the remaining lines as using the plot
#'function would generate a new plot each time, x represents the x values at which
#'the points that make up the line will be plotted, then the dt() function is used
#'to calculate the density function for the t-distribution. The x values at which the
#'density function is calculated is specified by x and the degrees of freedom are
#'specified by referencing the degrees_of_freedom vector. Once again type specifies
#'that this should be a line graph and the col= parameter is used to specify the
#'exact colour I want, notice the only value changing within the col= parameter
#'is alpha  which is responsible for the transparency of the colour, I decrease
#'the alpha value for each new degree of freedom as was done in the class slides.
legend(x = 4.5, y = 0.4, legend = c("normal", paste("t, df =", degrees_of_freedom)),
col = c(rgb(0.378, 0.847, 0.902, alpha = 1), rgb(0.378, 0.847, 0.902, alpha = 0.8), rgb(0.378, 0.847, 0.902, alpha = 0.6),
rgb(0.378, 0.847, 0.902, alpha = 0.4), rgb(0.378, 0.847, 0.902, alpha = 0.2)),
lty = 1, bty = "0.8", text.col = c(rgb(0.378, 0.847, 0.902, alpha = 1), rgb(0.378, 0.847, 0.902, alpha = 0.8), rgb(0.378, 0.847, 0.902, alpha = 0.6),
rgb(0.378, 0.847, 0.902, alpha = 0.4), rgb(0.378, 0.847, 0.902, alpha = 0.2)))
#'CODE ANALYSIS: In this line of code I specify the desired position of the legend by adding
#'x and y coordinates for each respective parameter, I then specify thee desired
#'legend labels. I then specify the colours that I want for each of the lines
#' and the text by filling in the col= and text.col= parameters. A box is added
#' around the legend using the bty=1 parameter. When choosing the colours I make
#' sure to match the alpha value for the respective names and lines so the amount
#' of fade in the colour matches for both th lines and the labels.
#Q1 (4 points):
#'Suppose 6 out of 15 students in a class develop influenza, whereas 20% of
#'similar school classes nationwide develop influenza. Is there evidence of an
#'excessive number of cases in the class? That is, what is the probability of
#'obtaining at least 6 cases in this class if the nationwide rate holds true?
p_morethan6 <- 1 - pbinom(5,size = 15, prob = 0.2)
print(p_morethan6)
class_size <- 15
nationwide_rate <- 0.2
expected_cases_based_on_rate <- class_size * nationwide_rate
print(expected_cases_based_on_rate)
#CODE ANALYSIS:In this line of code I use the pbinom() function to find the cumulative
#'probability of obtaining 5 cases of influenza and then I subtract this value
#'from 1. Subtracting this value from 1 yields the probability of obtaining
#'more than 5 cases of influenza which answers the question of what the probability
#'of obtaining at least 6 cases of influenza is taking into account the nationwide
#'rate which is assumed to be true. I also use a line of code to calculate the
#'expected number of influenza cases for a class of 15 students using the nationwide
#'rate of influenza for similar classes.
##################################################################################
#'Q2 (4 points):
#'A 60yr old male with no smoking history has symptoms of chronic cough and lung
#'biopsy consistent with both lung cancer and sarcoidosis (non fatal disease.
#'Let A = {symptoms}, B1 = normal, B2 = lung cancer, B3 = sarcoidosis, and
#'P(A|B1) = 0.001, P(A|B2) = 0.9, P(A|B3)=0.9.Also, for someone in this population
#'suppose that we have P(B1) = 0.99, P(B2) = 0.001, P(B3) = 0.009.
#'What are the probabilities for the three ``disease states'' given the symptoms?
P_AGB1 <- 0.001
P_AGB2 <- 0.9
P_AGB3 <- 0.9
P_B1 <- 0.99
P_B2 <- 0.001
P_B3 <- 0.009
P_B1GA <- (P_AGB1 * P_B1) / sum(P_AGB1 * P_B1, P_AGB2 * P_B2, P_AGB3 * P_B3)
P_B2GA <- (P_AGB2 * P_B2) / sum(P_AGB1 * P_B1, P_AGB2 * P_B2, P_AGB3 * P_B3)
P_B3GA <- (P_AGB3 * P_B3) / sum(P_AGB1 * P_B1, P_AGB2 * P_B2, P_AGB3 * P_B3)
print(P_B1GA)
print(P_B2GA)
print(P_B3GA)
#'CODE ANALYSIS: In this code I create a variable for each of the conditions
#'listed in the question while making sure to keep the variables self explanatory
#'so they can be easily interpreted. I then use Bayes Rule to calculate the
#'conditional probability for each of thee diseased states. I also use the print
#'function si my valuees are easily seen in the console.
##################################################################################
#'Q4 (3 points):
#'Consider the same setting and symptoms as in Q3 but this time for
#'a 60-yr male who smokes 2 packs of cigarettes a day. For this type of patient
#'the prevalence of disease states are different, P(B1) = 0.98; P(B2) = 0.015;
#'P(B3) = 0.005. What are the probabilities of the three ``disease states''
#'given the symptoms? Comment on the findings and the differences with the answer for Q3.
P2_B1 <- 0.98
P2_B2 <- 0.015
P2_B3 <- 0.005
P2_B1GA <- (P_AGB1 * P2_B1) / sum(P_AGB1 * P2_B1, P_AGB2 * P2_B2, P_AGB3 * P2_B3)
P2_B2GA <- (P_AGB2 * P2_B2) / sum(P_AGB1 * P2_B1, P_AGB2 * P2_B2, P_AGB3 * P2_B3)
P2_B3GA <- (P_AGB3 * P2_B3) / sum(P_AGB1 * P2_B1, P_AGB2 * P2_B2, P_AGB3 * P2_B3)
print(P2_B1GA)
print(P2_B2GA)
print(P2_B3GA)
P_Question2 <- c(0.99, 0.001, 0.009)
P_Question4 <- c(0.98, 0.015, 0.005)
P_DisStates_Question2 <- c(0.0990991, 0.09009009, 0.8108108)
P_DisStates_Question4 <- c(0.0516333, 0.711275, 0.2370917)
probability_table <- data.frame(Disease_State = c("Normal", "Lung Cancer", "Sarcoidosis"),
Q2_Inherent_Probability = P_Question2, Q4_Inherent_Probability = P_Question4,
Q2_Conditional_Probability = P_DisStates_Question2, Q4_Conditional_Probability = P_DisStates_Question4)
print(probability_table)
#'CODE ANALYSUIS:In this code I do the exact same calculation as in question 2 but
#'with the new values provided. I also makee a table comparing the values from
#'question 2 and queestion 4 so they can be more easily compared.
##################################################################################
#'Q5 (6 points):
#'Similar with other distributions, R has 4 functions for the
#'t-distribution. They have one parameter for the degrees of freedom (ignore the
#' “non-centrality parameter”). Use the function dt in a way similar to what we
#' covered in the tutorial, in order to reproduce the plot found in the slides,
#' with the densities of the standard normal and some t-distributions with
#' different degrees of freedom. You cannot use the plot function many times for
#' each density plot, as a new call of the plot function removes the previous plot.
#' Instead, after the first call of the plot function, you will need to use the
#' “points” function, witch has a very similar syntax with the plot function.
#' Every time you use the “points” function, a new plot is added to the existing
#' plot.Use the argument “col” in order to use different colors for the different
#' plots. Explore the “legend” function in order to create an informative legend
#' for the plot.
degrees_of_freedom <- c(8, 4, 2, 1)
#CODE ANALYSIS: With this line of code I aim to create a vector that contains the degrees of
#freedom that I am interested in for the t-distribution
x <- seq(-4, 8.5, length.out = 100)
#' CODE ANALYSIS: In this line of code I establish the range that I want to b plotted for my x-
#' value, I picked a range of -4 to 8.5 because this is the range that was used
#' in the example found in the class slides. I use the length.out function to
#' indicate the amount of values I want for there to be plotted for the sequence,
#' selecting a large number like 100 gives me a smooth plot.
plot(x, dnorm(x), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 1),
xlim = c(-4, 8), ylim = c(0, 0.7),
xlab = "", ylab = "", main = "t-distribtution examples", yaxt = "n", bty = "n")
tick_labels <- c("", "", "", "", "", "")
tick_positions <- c("-3", "-1", "1", "3", "5", "7")
axis(1, at = tick_positions, labels = tick_labels, tck = -0.005)
#' CODE ANALYSIS: For this code I plot the normal distribution using the plot() function to plot
#' the normal distribution. I use the dnorm() function to calculate the probability
#' density function for a standard normal distribution given the x values provided
#' previously. I then specify the type of plot as type = 1 which corresponds to a
#' line plot, the col parameter is specified using the rgb() function is used to
#' specify the exact colour I want for my plot line, the values added in this
#' function correspond to specific colour codes for red, blue, and green, allowing
#' me to generate the preferred shade of blue. The alpha = parameter lets me specify
#' the transparency of the colour which I left at 1 indicating 0% transparency.I
#' then indicated what I want my x axis and y axis length to be in thee xlim and
#' ylim parameters. I did not enter anything but quotations in the xlab and ylab
#' parameters because I do not want any axis labels as there wasn't any in the
#' class example. I made the title the same as the class example by adding the
#' name to the "main="parameter. I then add thee "yaxt=n" and "bty=n" parameters
#' which get rid of the y axis and box around the plot respectively. I also create
#' a vector called tick labels and tick positions and use these vectors to fill in
#' the parameters for thee axis() function. The tick_labels vector specifies that
#' at every tick there should not be any labels while the tick_position vector
#' has the points at which I would like my ticks to be placed on the plot. The tck
#' parameter specifies which direction I want the ticks to face and how long I want
#' them to be
points(x, dt(x, degrees_of_freedom[1]), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 0.8))
points(x, dt(x, degrees_of_freedom[2]), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 0.6))
points(x, dt(x, degrees_of_freedom[3]), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 0.4))
points(x, dt(x, degrees_of_freedom[4]), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 0.2))
#CODE ANALYSIS: Here I use the points function to plot the remaining lines as using the plot
#'function would generate a new plot each time, x represents the x values at which
#'the points that make up the line will be plotted, then the dt() function is used
#'to calculate the density function for the t-distribution. The x values at which the
#'density function is calculated is specified by x and the degrees of freedom are
#'specified by referencing the degrees_of_freedom vector. Once again type specifies
#'that this should be a line graph and the col= parameter is used to specify the
#'exact colour I want, notice the only value changing within the col= parameter
#'is alpha  which is responsible for the transparency of the colour, I decrease
#'the alpha value for each new degree of freedom as was done in the class slides.
legend(x = 4.5, y = 0.4, legend = c("normal", paste("t, df =", degrees_of_freedom)),
col = c(rgb(0.378, 0.847, 0.902, alpha = 1), rgb(0.378, 0.847, 0.902, alpha = 0.8), rgb(0.378, 0.847, 0.902, alpha = 0.6),
rgb(0.378, 0.847, 0.902, alpha = 0.4), rgb(0.378, 0.847, 0.902, alpha = 0.2)),
lty = 1, bty = "0.8", text.col = c(rgb(0.378, 0.847, 0.902, alpha = 1), rgb(0.378, 0.847, 0.902, alpha = 0.8), rgb(0.378, 0.847, 0.902, alpha = 0.6),
rgb(0.378, 0.847, 0.902, alpha = 0.4), rgb(0.378, 0.847, 0.902, alpha = 0.2)))
#'CODE ANALYSIS: In this line of code I specify the desired position of the legend by adding
#'x and y coordinates for each respective parameter, I then specify thee desired
#'legend labels. I then specify the colours that I want for each of the lines
#' and the text by filling in the col= and text.col= parameters. A box is added
#' around the legend using the bty=1 parameter. When choosing the colours I make
#' sure to match the alpha value for the respective names and lines so the amount
#' of fade in the colour matches for both th lines and the labels.
#install.packages("ISwR")
library(ISwR)
daily.intake <- c(5260,5470,5640,6180,6390,6515,6805,7515,7515,8230,8770)
mean(daily.intake)
#H0: mu=mu0=7725, H1: mu!=mu0
t.test(daily.intake,mu=7725,alternative = "less")
x.bar <- mean(daily.intake)
m0 <- 7725
s <- sd(daily.intake)
n <- length(daily.intake)
t.star <- (x.bar - m0)/(s/sqrt(n))
t.star
# t-distribution with df = n-1 = 10
# p-value = P(t_10 <= t.star)
pt(q=t.star,df=10)
#P(t_10 > -t.star)
pt(q=-t.star, df=10, lower.tail = F)
# p-value looks both ways
# since the distribution is symmetric, the value is 2 times the one tail
2*pt(q=t.star,df=10)
t.test(daily.intake,mu=7725,alternative = "two.sided")
t.test(daily.intake,mu=7725,alternative = "greater")
t.test(daily.intake,mu=7725,alternative = "greater")
# using Wilcoxon, two-sided
wilcox.test(daily.intake, mu=7725)
# using Wilcoxon, two-sided
wilcox.test(daily.intake, mu=7725)
energy
energy
boxplot(energy$expend ~ energy$stature)
boxplot(expend ~ stature, data=energy)
boxplot(expend ~ stature)
stripchart(expend ~ stature, method="jitter")
stripchart(expend ~ stature, method="jitter")
boxplot(energy$expend ~ energy$stature)
summary(energy)
# look at the energy data set
?energy
# using Wilcoxon, two-sided
wilcox.test(daily.intake, mu=7725)
t.test(daily.intake,mu=7725,alternative = "greater")
stripchart(expend ~ stature, method="jitter")
# BTC1859 - DATA SCIENCE IN HEALTH I
# SUMMER 2023
# TUTORIAL 4
# BY NICHOLAS MITSAKAKIS
# TOPICS:
# Statistical tests for continuous data
# T-test, wilcoxon test, anova
# Ways to plot data for exploratory analysis
setwd("~/Google Drive/IMI/MBIOTECH/DATA SCIENCE I 2023/TUTORIALS/TUTORIAL 4/")
#install.packages("ISwR")
library(ISwR)
daily.intake <- c(5260,5470,5640,6180,6390,6515,6805,7515,7515,8230,8770)
mean(daily.intake)
#same values as in intake$pre
#H0: mu=mu0=7725, H1: mu!=mu0
t.test(daily.intake,mu=7725,alternative = "less")
#Assuming a significance level of 0.05 we reject the null hypothesis that true mu
#is equal to 7725 for the alternative hypothesis that the true mean is less than 7725####
#Exercise: calculate the t-statistic "by hand"
x.bar <- mean(daily.intake)
m0 <- 7725
s <- sd(daily.intake)
n <- length(daily.intake)
t.star <- (x.bar - m0)/(s/sqrt(n))
t.star
# same as in the results of t.test
# t-distribution with df = n-1 = 10
# p-value = P(t_10 <= t.star)
pt(q=t.star,df=10)
# if we had a two-sided test what is the p-value?
# p-value = P(t_10 <= t.star OR -t.star <= t_10) = P(t_10 <= t.star) + P(-t.star <= t_10)
#P(t_10< -2.8 OR t_10 > 2.8)
#P(t_10 > -t.star)
pt(q=-t.star, df=10, lower.tail = F)
# notice the use of lower.tail = F argument
# p-value looks both ways
# since the distribution is symmetric, the value is 2 times the one tail
2*pt(q=t.star,df=10)
t.test(daily.intake,mu=7725,alternative = "two.sided")
# same p-value
# look at different options for the alternative hypothesis
t.test(daily.intake,mu=7725,alternative = "greater")
# using Wilcoxon, two-sided
wilcox.test(daily.intake, mu=7725)
# look at the energy data set
?energy
summary(energy)
# use of attach function, for convenience
attach(energy)
#detach(energy)
# compare energy expenditures for women with different statures
# Q: how can we plot them?
boxplot(energy$expend ~ energy$stature)
boxplot(expend ~ stature, data=energy)
boxplot(expend ~ stature)
stripchart(expend ~ stature, method="jitter")
# Q: other ways?
# as scatterplot
plot(expend,stature)
# plot calls boxplot
plot(expend ~ stature)
# 2-sample t.test using formula
t.test(expend~stature)
# alternative ways of performing the test
obese.vals <- expend[stature == "obese"]
lean.vals <- expend[stature == "lean"]
t.test(expend[stature=="obese"], expend[stature=="lean"])
t.test(obese.vals, lean.vals)
# note: the difference has the opposite direction from calling it with the formula. Why?
levels(stature)
wilcox.test(expend~stature)
detach(energy)
?intake
summary(intake)
str(intake)
attach(intake)
#if we want content of specific dataframe be visible to the environment we use the
#'attach function
post - pre
# Q: What is the best way to plot these data?
t.test(pre, post, paired=T)
# Q: Try non-paired
# Q: What did you observe?
# Example of study in the hospital
# Anonymous survey, pre and follow up
wilcox.test(pre, post, paired=T)
wilcox.test(pre, post, paired=F)
detach(intake)
# ANOVA
?red.cell.folate
attach(red.cell.folate)
str(red.cell.folate)
plot(folate~ventilation,data=red.cell.folate)
# Notice that it uses boxplot
# Q: How does it know to do that?
anova(lm(folate~ventilation))
# It generates the so-called ANOVA table, for F test
attach(juul)
table(tanner)
# incorrect use
anova(lm(igf1~tanner))
# why?
# create a factor
juul$tanner.fc <- factor(tanner, levels = 1:5)
# correct
anova(lm(igf1~tanner.fc,data=juul))
plot(igf1~tanner)
plot(igf1~tanner.fc)
stripchart(expend ~ stature, method="jitter")
# as scatterplot
plot(expend,stature)
daily.intake <- c(5260,5470,5640,6180,6390,6515,6805,7515,7515,8230,8770)
mean(daily.intake)
#same values as in intake$pre
#H0: mu=mu0=7725, H1: mu!=mu0
t.test(daily.intake,mu=7725,alternative = "less")
#Assuming a significance level of 0.05 we reject the null hypothesis that true mu
#is equal to 7725 for the alternative hypothesis that the true mean is less than 7725####
#Exercise: calculate the t-statistic "by hand"
x.bar <- mean(daily.intake)
m0 <- 7725
s <- sd(daily.intake)
n <- length(daily.intake)
t.star <- (x.bar - m0)/(s/sqrt(n))
t.star
# same as in the results of t.test
# t-distribution with df = n-1 = 10
# p-value = P(t_10 <= t.star)
pt(q=t.star,df=10)
# if we had a two-sided test what is the p-value?
# p-value = P(t_10 <= t.star OR -t.star <= t_10) = P(t_10 <= t.star) + P(-t.star <= t_10)
#P(t_10< -2.8 OR t_10 > 2.8)
#P(t_10 > -t.star)
pt(q=-t.star, df=10, lower.tail = F)
# notice the use of lower.tail = F argument
# p-value looks both ways
# since the distribution is symmetric, the value is 2 times the one tail
2*pt(q=t.star,df=10)
t.test(daily.intake,mu=7725,alternative = "two.sided")
# same p-value
# look at different options for the alternative hypothesis
t.test(daily.intake,mu=7725,alternative = "greater")
# using Wilcoxon, two-sided
wilcox.test(daily.intake, mu=7725)
# look at the energy data set
?energy
summary(energy)
# use of attach function, for convenience
attach(energy)
#detach(energy)
# compare energy expenditures for women with different statures
# Q: how can we plot them?
boxplot(energy$expend ~ energy$stature)
boxplot(expend ~ stature, data=energy)
boxplot(expend ~ stature)
stripchart(expend ~ stature, method="jitter")
# Q: other ways?
# as scatterplot
plot(expend,stature)
# plot calls boxplot
plot(expend ~ stature)
# 2-sample t.test using formula
t.test(expend~stature)
# alternative ways of performing the test
obese.vals <- expend[stature == "obese"]
lean.vals <- expend[stature == "lean"]
t.test(expend[stature=="obese"], expend[stature=="lean"])
t.test(obese.vals, lean.vals)
stripchart(expend ~ stature, method="jitter")
# 2-sample t.test using formula
t.test(expend~stature)
expend
t.test(expend[stature=="obese"], expend[stature=="lean"])
plot(x, dnorm(x), type = "l", col = rgb(0.378, 0.847, 0.902, alpha = 1),
xlim = c(-4, 8), ylim = c(0, 0.7),
xlab = "", ylab = "", main = "t-distribtution examples", yaxt = "n", bty = "n")
tick_labels <- c("", "", "", "", "", "")
tick_positions <- c("-3", "-1", "1", "3", "5", "7")
axis(1, at = tick_positions, labels = tick_labels, tck = -0.005)
#' CODE ANALYSIS: In this line of code I establish the range that I want to b plotted for my x-
#' value, I picked a range of -4 to 8.5 because this is the range that was used
#' in the example found in the class slides. I use the length.out function to
#' indicate the amount of values I want for there to be plotted for the sequence,
#' selecting a large number like 100 gives me a smooth plot.
?plot
plot(x, dnorm(x), type = "h", col = rgb(0.378, 0.847, 0.902, alpha = 1),
xlim = c(-4, 8), ylim = c(0, 0.7),
xlab = "", ylab = "", main = "t-distribtution examples", yaxt = "n", bty = "n")
tick_labels <- c("", "", "", "", "", "")
tick_positions <- c("-3", "-1", "1", "3", "5", "7")
axis(1, at = tick_positions, labels = tick_labels, tck = -0.005)
plot(x, dnorm(x), type = "s", col = rgb(0.378, 0.847, 0.902, alpha = 1),
xlim = c(-4, 8), ylim = c(0, 0.7),
xlab = "", ylab = "", main = "t-distribtution examples", yaxt = "n", bty = "n")
tick_labels <- c("", "", "", "", "", "")
tick_positions <- c("-3", "-1", "1", "3", "5", "7")
axis(1, at = tick_positions, labels = tick_labels, tck = -0.005)
plot(pre, postscript())
levels(stature)
wilcox.test(expend~stature)
detach(energy)
?intake
summary(intake)
str(intake)
attach(intake)
#if we want content of specific dataframe be visible to the environment we use the
#'attach function
post - pre
# Q: What is the best way to plot these data?
t.test(pre, post, paired=T)
# Q: Try non-paired
# Q: What did you observe?
# Example of study in the hospital
# Anonymous survey, pre and follow up
wilcox.test(pre, post, paired=T)
wilcox.test(pre, post, paired=F)
detach(intake)
# ANOVA
?red.cell.folate
attach(red.cell.folate)
str(red.cell.folate)
plot(folate~ventilation,data=red.cell.folate)
# Notice that it uses boxplot
# Q: How does it know to do that?
anova(lm(folate~ventilation))
# It generates the so-called ANOVA table, for F test
attach(juul)
table(tanner)
plot(pre, post)
plot(igf1~tanner)
plot(igf1~tanner.fc)
plot(igf1~tanner.fc,data=juul)
detach(juul)
plot(igf1~tanner)
# not working anymore
plot(igf1~tanner.fc,data=juul)
